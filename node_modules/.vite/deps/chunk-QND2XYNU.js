import {
  UniformBuffer
} from "./chunk-54BVPBEU.js";
import {
  InvertMatrixToRef,
  Matrix,
  MultiplyMatricesToRef
} from "./chunk-LJ4Q6UGK.js";
import {
  Effect
} from "./chunk-PQSXOQS4.js";

// node_modules/@babylonjs/core/Materials/floatingOriginMatrixOverrides.js
var TempFinalMat = new Matrix();
var TempMat1 = new Matrix();
var TempMat2 = new Matrix();
var FloatingOriginCurrentScene = {
  getScene: () => void 0,
  eyeAtCamera: true
  // When true, we can assume viewMatrix translation is at origin. Otherwise, we must do full offset calculations
};
function OffsetWorldToRef(offset, world, ref) {
  const refArray = ref.asArray();
  const worldArray = world.asArray();
  for (let i = 0; i < 16; i++) {
    refArray[i] = worldArray[i];
  }
  refArray[12] -= offset.x;
  refArray[13] -= offset.y;
  refArray[14] -= offset.z;
  ref.markAsUpdated();
  return ref;
}
function GetFullOffsetView(offset, viewMatrix, ref) {
  InvertMatrixToRef(viewMatrix, TempMat1);
  OffsetWorldToRef(offset, TempMat1, TempMat2);
  InvertMatrixToRef(TempMat2, ref);
  return ref;
}
function OffsetViewToRef(offset, view, ref) {
  if (!FloatingOriginCurrentScene.eyeAtCamera) {
    return GetFullOffsetView(offset, view, ref);
  }
  const refArray = ref.asArray();
  const viewArray = view.asArray();
  for (let i = 0; i < 16; i++) {
    refArray[i] = viewArray[i];
  }
  refArray[12] = 0;
  refArray[13] = 0;
  refArray[14] = 0;
  ref.markAsUpdated();
  return ref;
}
function OffsetViewProjectionToRef(offset, view, projection, ref) {
  MultiplyMatricesToRef(OffsetViewToRef(offset, view, ref), projection, ref);
  return ref;
}
function OffsetWorldViewToRef(offset, worldView, view, ref) {
  InvertMatrixToRef(view, TempMat1);
  MultiplyMatricesToRef(worldView, TempMat1, TempMat2);
  OffsetWorldToRef(offset, TempMat2, TempMat1);
  OffsetViewToRef(offset, view, TempMat2);
  MultiplyMatricesToRef(TempMat1, TempMat2, ref);
  return ref;
}
function OffsetWorldViewProjectionToRef(offset, worldViewProjection, viewProjection, view, projection, ref) {
  InvertMatrixToRef(viewProjection, TempMat1);
  MultiplyMatricesToRef(worldViewProjection, TempMat1, TempMat2);
  OffsetWorldToRef(offset, TempMat2, TempMat1);
  OffsetViewProjectionToRef(offset, view, projection, TempMat2);
  MultiplyMatricesToRef(TempMat1, TempMat2, ref);
  return ref;
}
function GetOffsetMatrix(uniformName, mat) {
  const scene = FloatingOriginCurrentScene.getScene();
  if (!scene || TempFinalMat === mat) {
    return mat;
  }
  TempFinalMat.updateFlag = mat.updateFlag;
  const offset = scene.floatingOriginOffset;
  switch (uniformName) {
    case "world":
      return OffsetWorldToRef(offset, mat, TempFinalMat);
    case "view":
      return OffsetViewToRef(offset, mat, TempFinalMat);
    case "worldView":
      return OffsetWorldViewToRef(offset, mat, scene.getViewMatrix(), TempFinalMat);
    case "viewProjection":
      return OffsetViewProjectionToRef(offset, scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);
    case "worldViewProjection":
      return OffsetWorldViewProjectionToRef(offset, mat, scene.getTransformMatrix(), scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);
    default:
      if (uniformName.startsWith("u_")) {
        const lowercaseUniformName = uniformName.toLowerCase();
        if (lowercaseUniformName.startsWith("u_worldviewprojection")) {
          return OffsetWorldViewProjectionToRef(offset, mat, scene.getTransformMatrix(), scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);
        }
        if (lowercaseUniformName.startsWith("u_viewprojection")) {
          return OffsetViewProjectionToRef(offset, scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);
        }
        if (lowercaseUniformName.startsWith("u_worldview")) {
          return OffsetWorldViewToRef(offset, mat, scene.getViewMatrix(), TempFinalMat);
        }
        if (lowercaseUniformName.startsWith("u_world")) {
          return OffsetWorldToRef(offset, mat, TempFinalMat);
        }
        if (lowercaseUniformName.startsWith("u_view")) {
          return OffsetViewToRef(offset, mat, TempFinalMat);
        }
      }
      return mat;
  }
}
var UniformBufferInternal = UniformBuffer;
var EffectInternal = Effect;
var OriginalUpdateMatrixForUniform = UniformBufferInternal.prototype._updateMatrixForUniform;
var OriginalSetMatrix = Effect.prototype.setMatrix;
function ResetMatrixFunctions() {
  Effect.prototype.setMatrix = OriginalSetMatrix;
  EffectInternal._setMatrixOverride = void 0;
  UniformBufferInternal.prototype._updateMatrixForUniform = OriginalUpdateMatrixForUniform;
  UniformBufferInternal.prototype._updateMatrixForUniformOverride = void 0;
}
function OverrideMatrixFunctions() {
  EffectInternal.prototype._setMatrixOverride = OriginalSetMatrix;
  EffectInternal.prototype.setMatrix = function(uniformName, matrix) {
    this._setMatrixOverride(uniformName, GetOffsetMatrix(uniformName, matrix));
    return this;
  };
  UniformBufferInternal.prototype._updateMatrixForUniformOverride = OriginalUpdateMatrixForUniform;
  UniformBufferInternal.prototype._updateMatrixForUniform = function(uniformName, matrix) {
    this._updateMatrixForUniformOverride(uniformName, GetOffsetMatrix(uniformName, matrix));
  };
}

// node_modules/@babylonjs/core/sceneComponent.js
var SceneComponentConstants = class {
};
SceneComponentConstants.NAME_EFFECTLAYER = "EffectLayer";
SceneComponentConstants.NAME_LAYER = "Layer";
SceneComponentConstants.NAME_LENSFLARESYSTEM = "LensFlareSystem";
SceneComponentConstants.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer";
SceneComponentConstants.NAME_PARTICLESYSTEM = "ParticleSystem";
SceneComponentConstants.NAME_GAMEPAD = "Gamepad";
SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue";
SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer";
SceneComponentConstants.NAME_PREPASSRENDERER = "PrePassRenderer";
SceneComponentConstants.NAME_DEPTHRENDERER = "DepthRenderer";
SceneComponentConstants.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer";
SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager";
SceneComponentConstants.NAME_SPRITE = "Sprite";
SceneComponentConstants.NAME_SUBSURFACE = "SubSurface";
SceneComponentConstants.NAME_OUTLINERENDERER = "Outline";
SceneComponentConstants.NAME_PROCEDURALTEXTURE = "ProceduralTexture";
SceneComponentConstants.NAME_SHADOWGENERATOR = "ShadowGenerator";
SceneComponentConstants.NAME_OCTREE = "Octree";
SceneComponentConstants.NAME_PHYSICSENGINE = "PhysicsEngine";
SceneComponentConstants.NAME_AUDIO = "Audio";
SceneComponentConstants.NAME_FLUIDRENDERER = "FluidRenderer";
SceneComponentConstants.NAME_IBLCDFGENERATOR = "iblCDFGenerator";
SceneComponentConstants.NAME_CLUSTEREDLIGHTING = "ClusteredLighting";
SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER = 0;
SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;
SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS = 0;
SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1;
SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER = 2;
SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0;
SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER = 1;
SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS = 0;
SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE = 1;
SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE = 1;
SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;
SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;
SceneComponentConstants.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;
SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;
SceneComponentConstants.STEP_BEFORECLEAR_PREPASS = 1;
SceneComponentConstants.STEP_BEFORERENDERTARGETCLEAR_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER = 1;
SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS = 0;
SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1;
SceneComponentConstants.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2;
SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3;
SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER = 4;
SceneComponentConstants.STEP_AFTERCAMERADRAW_FLUIDRENDERER = 5;
SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER = 0;
SceneComponentConstants.STEP_AFTERRENDER_AUDIO = 0;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER = 1;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_CLUSTEREDLIGHTING = 2;
SceneComponentConstants.STEP_POINTERMOVE_SPRITE = 0;
SceneComponentConstants.STEP_POINTERDOWN_SPRITE = 0;
SceneComponentConstants.STEP_POINTERUP_SPRITE = 0;
var Stage = class _Stage extends Array {
  /**
   * Hide ctor from the rest of the world.
   * @param items The items to add.
   */
  constructor(items) {
    super(...items);
  }
  /**
   * Creates a new Stage.
   * @returns A new instance of a Stage
   */
  static Create() {
    return Object.create(_Stage.prototype);
  }
  /**
   * Registers a step in an ordered way in the targeted stage.
   * @param index Defines the position to register the step in
   * @param component Defines the component attached to the step
   * @param action Defines the action to launch during the step
   */
  registerStep(index, component, action) {
    let i = 0;
    let maxIndex = Number.MAX_VALUE;
    for (; i < this.length; i++) {
      const step = this[i];
      maxIndex = step.index;
      if (index < maxIndex) {
        break;
      }
    }
    this.splice(i, 0, { index, component, action: action.bind(component) });
  }
  /**
   * Clears all the steps from the stage.
   */
  clear() {
    this.length = 0;
  }
};

// node_modules/@babylonjs/core/Events/keyboardEvents.js
var KeyboardEventTypes = class {
};
KeyboardEventTypes.KEYDOWN = 1;
KeyboardEventTypes.KEYUP = 2;
var KeyboardInfo = class {
  /**
   * Instantiates a new keyboard info.
   * This class is used to store keyboard related info for the onKeyboardObservable event.
   * @param type Defines the type of event (KeyboardEventTypes)
   * @param event Defines the related dom event
   */
  constructor(type, event) {
    this.type = type;
    this.event = event;
  }
};
var KeyboardInfoPre = class extends KeyboardInfo {
  /**
   * Defines whether the engine should skip the next onKeyboardObservable associated to this pre.
   * @deprecated use skipOnKeyboardObservable property instead
   */
  get skipOnPointerObservable() {
    return this.skipOnKeyboardObservable;
  }
  set skipOnPointerObservable(value) {
    this.skipOnKeyboardObservable = value;
  }
  /**
   * Instantiates a new keyboard pre info.
   * This class is used to store keyboard related info for the onPreKeyboardObservable event.
   * @param type Defines the type of event (KeyboardEventTypes)
   * @param event Defines the related dom event
   */
  constructor(type, event) {
    super(type, event);
    this.type = type;
    this.event = event;
    this.skipOnKeyboardObservable = false;
  }
};

export {
  FloatingOriginCurrentScene,
  ResetMatrixFunctions,
  OverrideMatrixFunctions,
  SceneComponentConstants,
  Stage,
  KeyboardEventTypes,
  KeyboardInfo,
  KeyboardInfoPre
};
//# sourceMappingURL=chunk-QND2XYNU.js.map
