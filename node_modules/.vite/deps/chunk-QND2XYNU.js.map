{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/floatingOriginMatrixOverrides.ts", "../../../dev/core/src/sceneComponent.ts", "../../../dev/core/src/Events/keyboardEvents.ts"],
  "sourcesContent": ["import { Effect } from \"../Materials/effect\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { IMatrixLike, IVector3Like } from \"../Maths/math.like\";\r\nimport { InvertMatrixToRef, MultiplyMatricesToRef } from \"../Maths/ThinMaths/thinMath.matrix.functions\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { DeepImmutable } from \"../types\";\r\nimport { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nconst TempFinalMat: Matrix = new Matrix();\r\nconst TempMat1: Matrix = new Matrix();\r\nconst TempMat2: Matrix = new Matrix();\r\n\r\n/**\r\n * When rendering, each scene will reset this to ensure the correct floating origin offset is when overriding the below functions\r\n */\r\nexport const FloatingOriginCurrentScene = {\r\n    getScene: () => undefined as Scene | undefined,\r\n    eyeAtCamera: true, // When true, we can assume viewMatrix translation is at origin. Otherwise, we must do full offset calculations\r\n};\r\n\r\nfunction OffsetWorldToRef(offset: IVector3Like, world: DeepImmutable<IMatrixLike>, ref: Matrix): DeepImmutable<IMatrixLike> {\r\n    const refArray = ref.asArray();\r\n    const worldArray = world.asArray();\r\n    for (let i = 0; i < 16; i++) {\r\n        refArray[i] = worldArray[i];\r\n    }\r\n    refArray[12] -= offset.x;\r\n    refArray[13] -= offset.y;\r\n    refArray[14] -= offset.z;\r\n    ref.markAsUpdated();\r\n    return ref;\r\n}\r\n\r\nfunction GetFullOffsetView(offset: IVector3Like, viewMatrix: DeepImmutable<IMatrixLike>, ref: IMatrixLike) {\r\n    InvertMatrixToRef(viewMatrix, TempMat1); // TempMat1 = light world matrix (inverse of view)\r\n    OffsetWorldToRef(offset, TempMat1, TempMat2); // TempMat2 = offset light world matrix\r\n    InvertMatrixToRef(TempMat2, ref); // TempMat1 = offset view matrix\r\n    return ref;\r\n}\r\n\r\nexport function OffsetViewToRef(offset: IVector3Like, view: DeepImmutable<IMatrixLike>, ref: Matrix): DeepImmutable<IMatrixLike> {\r\n    // When eye is not at camera, we cannot assume the translation of view matrix is at origin, so we perform full offset calculation\r\n    if (!FloatingOriginCurrentScene.eyeAtCamera) {\r\n        return GetFullOffsetView(offset, view, ref);\r\n    }\r\n    const refArray = ref.asArray();\r\n    const viewArray = view.asArray();\r\n    for (let i = 0; i < 16; i++) {\r\n        refArray[i] = viewArray[i];\r\n    }\r\n    refArray[12] = 0;\r\n    refArray[13] = 0;\r\n    refArray[14] = 0;\r\n    ref.markAsUpdated();\r\n    return ref;\r\n}\r\n\r\nfunction OffsetViewProjectionToRef(offset: IVector3Like, view: DeepImmutable<IMatrixLike>, projection: DeepImmutable<IMatrixLike>, ref: Matrix): DeepImmutable<IMatrixLike> {\r\n    MultiplyMatricesToRef(OffsetViewToRef(offset, view, ref), projection, ref);\r\n    return ref;\r\n}\r\n\r\nexport function OffsetClipPlaneToRef(offset: Vector3, plane: Plane, ref: Plane): Plane {\r\n    // Original clipplane is using equation normal.dot(p) + d = 0\r\n    // Assume we have p' = p - offset, that means normal.dot(p') + d' = 0\r\n    // So to get the offset plane,\r\n    // normal.dot(p' + offset) + d = 0\r\n    // normal.dot(p') + normal.dot(offset) + d = 0\r\n    // -d' + normal.dot(offset) + d = 0\r\n    // d' = d + normal.dot(offset)\r\n    ref.normal.copyFrom(plane.normal);\r\n    ref.d = plane.d + Vector3.Dot(plane.normal, offset);\r\n    return ref;\r\n}\r\n\r\nexport function GetOffsetTransformMatrices(\r\n    offset: IVector3Like,\r\n    viewMatrices: Array<Matrix>,\r\n    projectionMatrices: Array<Matrix>,\r\n    length: number,\r\n    resultArray: Float32Array\r\n): Float32Array {\r\n    for (let cascadeIndex = 0; cascadeIndex < length; ++cascadeIndex) {\r\n        GetFullOffsetViewProjectionToRef(offset, viewMatrices[cascadeIndex], projectionMatrices[cascadeIndex], TempMat1);\r\n        TempMat1.copyToArray(resultArray, cascadeIndex * 16);\r\n    }\r\n    return resultArray;\r\n}\r\n\r\nfunction OffsetWorldViewToRef(offset: IVector3Like, worldView: DeepImmutable<IMatrixLike>, view: DeepImmutable<IMatrixLike>, ref: Matrix): DeepImmutable<IMatrixLike> {\r\n    // ( world * view ) * inverse ( view ) = world\r\n    InvertMatrixToRef(view, TempMat1); // TempMat1 = inverseView\r\n    MultiplyMatricesToRef(worldView, TempMat1, TempMat2); // TempMat2 = world, TempMat1 can be reused\r\n\r\n    // ( offsetWorld * offsetView ) = offsetWorldView\r\n    OffsetWorldToRef(offset, TempMat2, TempMat1); // TempMat1 = offsetWorld\r\n    OffsetViewToRef(offset, view, TempMat2); // TempMat2 = offsetView\r\n    MultiplyMatricesToRef(TempMat1, TempMat2, ref);\r\n\r\n    return ref;\r\n}\r\n\r\nexport function GetFullOffsetViewProjectionToRef(\r\n    offset: IVector3Like,\r\n    viewMatrix: DeepImmutable<IMatrixLike>,\r\n    projectionMatrix: DeepImmutable<IMatrixLike>,\r\n    ref: IMatrixLike\r\n): DeepImmutable<IMatrixLike> {\r\n    GetFullOffsetView(offset, viewMatrix, TempMat2);\r\n    MultiplyMatricesToRef(TempMat2, projectionMatrix, ref);\r\n    return ref;\r\n}\r\n\r\nfunction OffsetWorldViewProjectionToRef(\r\n    offset: IVector3Like,\r\n    worldViewProjection: DeepImmutable<IMatrixLike>,\r\n    viewProjection: DeepImmutable<IMatrixLike>,\r\n    view: DeepImmutable<IMatrixLike>,\r\n    projection: DeepImmutable<IMatrixLike>,\r\n    ref: IMatrixLike\r\n): DeepImmutable<IMatrixLike> {\r\n    // ( world * view * projection ) * inverse(projection) * inverse(view) = world\r\n    // ( world * view * projection ) * inverse (view * projection) = world\r\n    InvertMatrixToRef(viewProjection, TempMat1); // TempMat1 = inverse (view * projection)\r\n    MultiplyMatricesToRef(worldViewProjection, TempMat1, TempMat2); // TempMat2 = world, TempMat1 can be reused\r\n\r\n    // ( offsetWorld * offsetViewProjection)  = offsetWorldViewProjection\r\n    OffsetWorldToRef(offset, TempMat2, TempMat1); // TempMat1 = offsetWorld\r\n    OffsetViewProjectionToRef(offset, view, projection, TempMat2); // TempMat2 = offsetViewProjection\r\n    MultiplyMatricesToRef(TempMat1, TempMat2, ref);\r\n\r\n    return ref;\r\n}\r\n\r\nfunction GetOffsetMatrix(uniformName: string, mat: IMatrixLike): IMatrixLike {\r\n    const scene = FloatingOriginCurrentScene.getScene();\r\n    // Early out for scenes that don't have floatingOriginMode enabled\r\n    // Effect.setMatrix will call pipelineContext.setMatrix. In WebGPU, this will in turn call ubo.updateMatrix. To avoid double offset, early out if mat is TempFinalMat\r\n    if (!scene || TempFinalMat === mat) {\r\n        return mat;\r\n    }\r\n    TempFinalMat.updateFlag = mat.updateFlag;\r\n    const offset = scene.floatingOriginOffset;\r\n    switch (uniformName) {\r\n        case \"world\":\r\n            return OffsetWorldToRef(offset, mat, TempFinalMat);\r\n        case \"view\":\r\n            return OffsetViewToRef(offset, mat, TempFinalMat);\r\n        case \"worldView\":\r\n            return OffsetWorldViewToRef(offset, mat, scene.getViewMatrix(), TempFinalMat);\r\n        case \"viewProjection\":\r\n            return OffsetViewProjectionToRef(offset, scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);\r\n        case \"worldViewProjection\":\r\n            return OffsetWorldViewProjectionToRef(offset, mat, scene.getTransformMatrix(), scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);\r\n        default:\r\n            // Node material blocks uniforms are formatted u_BlockName, with trailing numbers if there are multiple blocks of the same name\r\n            // Check u_ first so that we can early out for non-node material uniforms\r\n            if (uniformName.startsWith(\"u_\")) {\r\n                const lowercaseUniformName = uniformName.toLowerCase();\r\n                if (lowercaseUniformName.startsWith(\"u_worldviewprojection\")) {\r\n                    return OffsetWorldViewProjectionToRef(offset, mat, scene.getTransformMatrix(), scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);\r\n                }\r\n                if (lowercaseUniformName.startsWith(\"u_viewprojection\")) {\r\n                    return OffsetViewProjectionToRef(offset, scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);\r\n                }\r\n                if (lowercaseUniformName.startsWith(\"u_worldview\")) {\r\n                    return OffsetWorldViewToRef(offset, mat, scene.getViewMatrix(), TempFinalMat);\r\n                }\r\n                if (lowercaseUniformName.startsWith(\"u_world\")) {\r\n                    return OffsetWorldToRef(offset, mat, TempFinalMat);\r\n                }\r\n                if (lowercaseUniformName.startsWith(\"u_view\")) {\r\n                    return OffsetViewToRef(offset, mat, TempFinalMat);\r\n                }\r\n            }\r\n            return mat;\r\n    }\r\n}\r\n\r\n// ---- Overriding the prototypes of effect and uniformBuffer's setMatrix functions ----\r\nconst UniformBufferInternal = UniformBuffer as any;\r\nconst EffectInternal = Effect as any;\r\nconst OriginalUpdateMatrixForUniform = UniformBufferInternal.prototype._updateMatrixForUniform;\r\nconst OriginalSetMatrix = Effect.prototype.setMatrix;\r\n\r\nexport function ResetMatrixFunctions() {\r\n    Effect.prototype.setMatrix = OriginalSetMatrix;\r\n    EffectInternal._setMatrixOverride = undefined;\r\n    UniformBufferInternal.prototype._updateMatrixForUniform = OriginalUpdateMatrixForUniform;\r\n    UniformBufferInternal.prototype._updateMatrixForUniformOverride = undefined;\r\n}\r\n\r\nexport function OverrideMatrixFunctions() {\r\n    EffectInternal.prototype._setMatrixOverride = OriginalSetMatrix;\r\n    EffectInternal.prototype.setMatrix = function (uniformName: string, matrix: IMatrixLike) {\r\n        this._setMatrixOverride(uniformName, GetOffsetMatrix(uniformName, matrix));\r\n        return this;\r\n    };\r\n    UniformBufferInternal.prototype._updateMatrixForUniformOverride = OriginalUpdateMatrixForUniform;\r\n    UniformBufferInternal.prototype._updateMatrixForUniform = function (uniformName: string, matrix: IMatrixLike) {\r\n        this._updateMatrixForUniformOverride(uniformName, GetOffsetMatrix(uniformName, matrix));\r\n    };\r\n}\r\n", "import type { Scene } from \"./scene\";\r\nimport type { SmartArrayNoDuplicate } from \"./Misc/smartArray\";\r\nimport type { Nullable } from \"./types\";\r\nimport type { PickingInfo } from \"./Collisions/pickingInfo\";\r\nimport type { IPointerEvent } from \"./Events/deviceInputEvents\";\r\n\r\nimport type { Mesh } from \"./Meshes/mesh\";\r\nimport type { Effect } from \"./Materials/effect\";\r\nimport type { Camera } from \"./Cameras/camera\";\r\nimport type { AbstractMesh } from \"./Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"./Meshes/subMesh\";\r\nimport type { RenderTargetTexture } from \"./Materials/Textures/renderTargetTexture\";\r\nimport type { IAssetContainer } from \"./IAssetContainer\";\r\n\r\n/**\r\n * Groups all the scene component constants in one place to ease maintenance.\r\n * @internal\r\n */\r\nexport class SceneComponentConstants {\r\n    public static readonly NAME_EFFECTLAYER = \"EffectLayer\";\r\n    public static readonly NAME_LAYER = \"Layer\";\r\n    public static readonly NAME_LENSFLARESYSTEM = \"LensFlareSystem\";\r\n    public static readonly NAME_BOUNDINGBOXRENDERER = \"BoundingBoxRenderer\";\r\n    public static readonly NAME_PARTICLESYSTEM = \"ParticleSystem\";\r\n    public static readonly NAME_GAMEPAD = \"Gamepad\";\r\n    public static readonly NAME_SIMPLIFICATIONQUEUE = \"SimplificationQueue\";\r\n    public static readonly NAME_GEOMETRYBUFFERRENDERER = \"GeometryBufferRenderer\";\r\n    public static readonly NAME_PREPASSRENDERER = \"PrePassRenderer\";\r\n    public static readonly NAME_DEPTHRENDERER = \"DepthRenderer\";\r\n    public static readonly NAME_DEPTHPEELINGRENDERER = \"DepthPeelingRenderer\";\r\n    public static readonly NAME_POSTPROCESSRENDERPIPELINEMANAGER = \"PostProcessRenderPipelineManager\";\r\n    public static readonly NAME_SPRITE = \"Sprite\";\r\n    public static readonly NAME_SUBSURFACE = \"SubSurface\";\r\n    public static readonly NAME_OUTLINERENDERER = \"Outline\";\r\n    public static readonly NAME_PROCEDURALTEXTURE = \"ProceduralTexture\";\r\n    public static readonly NAME_SHADOWGENERATOR = \"ShadowGenerator\";\r\n    public static readonly NAME_OCTREE = \"Octree\";\r\n    public static readonly NAME_PHYSICSENGINE = \"PhysicsEngine\";\r\n    public static readonly NAME_AUDIO = \"Audio\";\r\n    public static readonly NAME_FLUIDRENDERER = \"FluidRenderer\";\r\n    public static readonly NAME_IBLCDFGENERATOR = \"iblCDFGenerator\";\r\n    public static readonly NAME_CLUSTEREDLIGHTING = \"ClusteredLighting\";\r\n\r\n    public static readonly STEP_ISREADYFORMESH_EFFECTLAYER = 0;\r\n\r\n    public static readonly STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;\r\n\r\n    public static readonly STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;\r\n\r\n    public static readonly STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;\r\n\r\n    public static readonly STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;\r\n\r\n    public static readonly STEP_BEFORECAMERADRAW_PREPASS = 0;\r\n    public static readonly STEP_BEFORECAMERADRAW_EFFECTLAYER = 1;\r\n    public static readonly STEP_BEFORECAMERADRAW_LAYER = 2;\r\n\r\n    public static readonly STEP_BEFORERENDERTARGETDRAW_PREPASS = 0;\r\n    public static readonly STEP_BEFORERENDERTARGETDRAW_LAYER = 1;\r\n\r\n    public static readonly STEP_BEFORERENDERINGMESH_PREPASS = 0;\r\n    public static readonly STEP_BEFORERENDERINGMESH_OUTLINE = 1;\r\n\r\n    public static readonly STEP_AFTERRENDERINGMESH_PREPASS = 0;\r\n    public static readonly STEP_AFTERRENDERINGMESH_OUTLINE = 1;\r\n\r\n    public static readonly STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;\r\n    public static readonly STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;\r\n\r\n    public static readonly STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;\r\n\r\n    public static readonly STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;\r\n    public static readonly STEP_BEFORECLEAR_PREPASS = 1;\r\n\r\n    public static readonly STEP_BEFORERENDERTARGETCLEAR_PREPASS = 0;\r\n\r\n    public static readonly STEP_AFTERRENDERTARGETDRAW_PREPASS = 0;\r\n    public static readonly STEP_AFTERRENDERTARGETDRAW_LAYER = 1;\r\n\r\n    public static readonly STEP_AFTERCAMERADRAW_PREPASS = 0;\r\n    public static readonly STEP_AFTERCAMERADRAW_EFFECTLAYER = 1;\r\n    public static readonly STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2;\r\n    public static readonly STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3;\r\n    public static readonly STEP_AFTERCAMERADRAW_LAYER = 4;\r\n    public static readonly STEP_AFTERCAMERADRAW_FLUIDRENDERER = 5;\r\n\r\n    public static readonly STEP_AFTERCAMERAPOSTPROCESS_LAYER = 0;\r\n\r\n    public static readonly STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER = 0;\r\n\r\n    public static readonly STEP_AFTERRENDER_AUDIO = 0;\r\n\r\n    public static readonly STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;\r\n    public static readonly STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;\r\n    public static readonly STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;\r\n    public static readonly STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;\r\n\r\n    public static readonly STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;\r\n    public static readonly STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER = 1;\r\n    public static readonly STEP_GATHERACTIVECAMERARENDERTARGETS_CLUSTEREDLIGHTING = 2;\r\n\r\n    public static readonly STEP_POINTERMOVE_SPRITE = 0;\r\n    public static readonly STEP_POINTERDOWN_SPRITE = 0;\r\n    public static readonly STEP_POINTERUP_SPRITE = 0;\r\n}\r\n\r\n/**\r\n * This represents a scene component.\r\n *\r\n * This is used to decouple the dependency the scene is having on the different workloads like\r\n * layers, post processes...\r\n */\r\nexport interface ISceneComponent {\r\n    /**\r\n     * The name of the component. Each component must have a unique name.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    scene: Scene;\r\n\r\n    /**\r\n     * Register the component to one instance of a scene.\r\n     */\r\n    register(): void;\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    rebuild(): void;\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    dispose(): void;\r\n}\r\n\r\n/**\r\n * This represents a SERIALIZABLE scene component.\r\n *\r\n * This extends Scene Component to add Serialization methods on top.\r\n */\r\nexport interface ISceneSerializableComponent extends ISceneComponent {\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    addFromContainer(container: IAssetContainer): void;\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    removeFromContainer(container: IAssetContainer, dispose?: boolean): void;\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    serialize(serializationObject: any): void;\r\n}\r\n\r\n/**\r\n * Strong typing of a Mesh related stage step action\r\n */\r\nexport type MeshStageAction = (mesh: AbstractMesh, hardwareInstancedRendering: boolean) => boolean;\r\n\r\n/**\r\n * Strong typing of a Evaluate Sub Mesh related stage step action\r\n */\r\nexport type EvaluateSubMeshStageAction = (mesh: AbstractMesh, subMesh: SubMesh) => void;\r\n\r\n/**\r\n * Strong typing of a pre active Mesh related stage step action\r\n */\r\nexport type PreActiveMeshStageAction = (mesh: AbstractMesh) => void;\r\n\r\n/**\r\n * Strong typing of a Camera related stage step action\r\n */\r\nexport type CameraStageAction = (camera: Camera) => void;\r\n\r\n/**\r\n * Strong typing of a Camera Frame buffer related stage step action\r\n */\r\nexport type CameraStageFrameBufferAction = (camera: Camera) => boolean;\r\n\r\n/**\r\n * Strong typing of a Render Target related stage step action\r\n */\r\nexport type RenderTargetStageAction = (renderTarget: RenderTargetTexture, faceIndex?: number, layer?: number) => void;\r\n\r\n/**\r\n * Strong typing of a RenderingGroup related stage step action\r\n */\r\nexport type RenderingGroupStageAction = (renderingGroupId: number) => void;\r\n\r\n/**\r\n * Strong typing of a Mesh Render related stage step action\r\n */\r\nexport type RenderingMeshStageAction = (mesh: Mesh, subMesh: SubMesh, batch: any, effect: Nullable<Effect>) => void;\r\n\r\n/**\r\n * Strong typing of a simple stage step action\r\n */\r\nexport type SimpleStageAction = () => void;\r\n\r\n/**\r\n * Strong typing of a render target action.\r\n */\r\nexport type RenderTargetsStageAction = (renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>) => void;\r\n\r\n/**\r\n * Strong typing of a pointer move action.\r\n */\r\nexport type PointerMoveStageAction = (\r\n    unTranslatedPointerX: number,\r\n    unTranslatedPointerY: number,\r\n    pickResult: Nullable<PickingInfo>,\r\n    isMeshPicked: boolean,\r\n    element: Nullable<HTMLElement>\r\n) => Nullable<PickingInfo>;\r\n\r\n/**\r\n * Strong typing of a pointer up/down action.\r\n */\r\nexport type PointerUpDownStageAction = (\r\n    unTranslatedPointerX: number,\r\n    unTranslatedPointerY: number,\r\n    pickResult: Nullable<PickingInfo>,\r\n    evt: IPointerEvent,\r\n    doubleClick: boolean\r\n) => Nullable<PickingInfo>;\r\n\r\n/**\r\n * Representation of a stage in the scene (Basically a list of ordered steps)\r\n * @internal\r\n */\r\nexport class Stage<T extends Function> extends Array<{ index: number; component: ISceneComponent; action: T }> {\r\n    /**\r\n     * Hide ctor from the rest of the world.\r\n     * @param items The items to add.\r\n     */\r\n    private constructor(items?: { index: number; component: ISceneComponent; action: T }[]) {\r\n        super(...(<any>items));\r\n    }\r\n\r\n    /**\r\n     * Creates a new Stage.\r\n     * @returns A new instance of a Stage\r\n     */\r\n    static Create<T extends Function>(): Stage<T> {\r\n        return Object.create(Stage.prototype) as Stage<T>;\r\n    }\r\n\r\n    /**\r\n     * Registers a step in an ordered way in the targeted stage.\r\n     * @param index Defines the position to register the step in\r\n     * @param component Defines the component attached to the step\r\n     * @param action Defines the action to launch during the step\r\n     */\r\n    public registerStep(index: number, component: ISceneComponent, action: T): void {\r\n        let i = 0;\r\n        let maxIndex = Number.MAX_VALUE;\r\n        for (; i < this.length; i++) {\r\n            const step = this[i];\r\n            maxIndex = step.index;\r\n            if (index < maxIndex) {\r\n                break;\r\n            }\r\n        }\r\n        this.splice(i, 0, { index, component, action: action.bind(component) });\r\n    }\r\n\r\n    /**\r\n     * Clears all the steps from the stage.\r\n     */\r\n    public clear(): void {\r\n        this.length = 0;\r\n    }\r\n}\r\n", "import type { IKeyboardEvent } from \"./deviceInputEvents\";\r\n\r\n/**\r\n * Gather the list of keyboard event types as constants.\r\n */\r\nexport class KeyboardEventTypes {\r\n    /**\r\n     * The keydown event is fired when a key becomes active (pressed).\r\n     */\r\n    public static readonly KEYDOWN = 0x01;\r\n    /**\r\n     * The keyup event is fired when a key has been released.\r\n     */\r\n    public static readonly KEYUP = 0x02;\r\n}\r\n\r\n/**\r\n * This class is used to store keyboard related info for the onKeyboardObservable event.\r\n */\r\nexport class KeyboardInfo {\r\n    /**\r\n     * Instantiates a new keyboard info.\r\n     * This class is used to store keyboard related info for the onKeyboardObservable event.\r\n     * @param type Defines the type of event (KeyboardEventTypes)\r\n     * @param event Defines the related dom event\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the type of event (KeyboardEventTypes)\r\n         */\r\n        public type: number,\r\n        /**\r\n         * Defines the related dom event\r\n         */\r\n        public event: IKeyboardEvent\r\n    ) {}\r\n}\r\n\r\n/**\r\n * This class is used to store keyboard related info for the onPreKeyboardObservable event.\r\n * Set the skipOnKeyboardObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onKeyboardObservable\r\n */\r\nexport class KeyboardInfoPre extends KeyboardInfo {\r\n    /**\r\n     * Defines whether the engine should skip the next onKeyboardObservable associated to this pre.\r\n     */\r\n    public skipOnKeyboardObservable: boolean;\r\n\r\n    /**\r\n     * Defines whether the engine should skip the next onKeyboardObservable associated to this pre.\r\n     * @deprecated use skipOnKeyboardObservable property instead\r\n     */\r\n    public get skipOnPointerObservable() {\r\n        return this.skipOnKeyboardObservable;\r\n    }\r\n    public set skipOnPointerObservable(value) {\r\n        this.skipOnKeyboardObservable = value;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new keyboard pre info.\r\n     * This class is used to store keyboard related info for the onPreKeyboardObservable event.\r\n     * @param type Defines the type of event (KeyboardEventTypes)\r\n     * @param event Defines the related dom event\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the type of event (KeyboardEventTypes)\r\n         */\r\n        public override type: number,\r\n        /**\r\n         * Defines the related dom event\r\n         */\r\n        public override event: IKeyboardEvent\r\n    ) {\r\n        super(type, event);\r\n        this.skipOnKeyboardObservable = false;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
